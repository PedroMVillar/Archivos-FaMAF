---
Materia: Algoritmos1
tags:
  - haskell
---
Haskell es un **lenguaje de programación puramente funcional**. En los lenguajes imperativos obtenemos resultados dándole al computador una secuencia de tareas que luego éste ejecutará. Mientras las ejecuta, puede cambiar de estado. Por ejemplo, establecemos la variable a a 5, realizamos algunas tareas y luego cambiamos el valor de la variable anterior. Estos lenguajes poseen estructuras de control de flujo para realizar ciertas acciones varias veces (for, while...). Con la programación puramente funcional no decimos al computador lo que tiene que hacer, sino más bien, decimos como son las cosas. El factorial de un número es el producto de todos los números desde el 1 hasta ese número, la suma de una lista de números es el primer número más la suma del resto de la lista, etc. Expresamos la forma de las funciones. Además no podemos establecer una variable a algo y luego establecerla a otra cosa. Si decimos que a es 5, luego no podemos decir que es otra cosa porque acabamos de decir que es 5 ¿Acaso somos unos mentirosos? De este modo, en los lenguajes puramente funcionales, una función no tiene efectos secundarios. Lo único que puede hacer una función es calcular y devolver algo como resultado. Al principio esto puede parecer una limitación pero en realidad tiene algunas buenas consecuencias: si una función es llamada dos veces con los mismos parámetros, obtendremos siempre el mismo resultado. A esto lo llamamos _transparencia referencial_ y no solo permite al compilador razonar acerca de el comportamiento de un programa, sino que también nos permite deducir fácilmente (e incluso demostrar) que una función es correcta y así poder construir funciones más complejas uniendo funciones simples.

## Perezoso
Haskell es **perezoso**. Es decir, a menos que le indiquemos lo contrario, Haskell no ejecutará funciones ni calculará resultados hasta que se vea realmente forzado a hacerlo. Esto funciona muy bien junto con la transparencia referencial y permite que veamos los programas como una serie de transformaciones de datos. Incluso nos permite hacer cosas interesantes como estructuras de datos infinitas. Digamos que tenemos una lista de números inmutables xs = [1,2,3,4,5,6,7,8] y una función doubleMe que multiplica cada elemento por 2 y devuelve una nueva lista. Si quisiéramos multiplicar nuestra lista por 8 en un lenguaje imperativo he hiciéramos doubleMe(doubleMe(doubleMe(xs))), probablemente el computador recorrería la lista, haría una copia y devolvería el valor. Luego, recorrería otras dos veces más la lista y devolvería el valor final. En un lenguaje perezoso, llamar a doubleMe con una lista sin forzar que muestre el valor acaba con un programa diciéndote “Claro claro, ¡luego lo hago!”. Pero cuando quieres ver el resultado, el primer doubleMe dice al segundo que quiere el resultado, ¡ahora! El segundo dice al tercero eso mismo y éste a regañadientes devuelve un 1 duplicado, lo cual es un 2. El segundo lo recibe y devuelve un 4 al primero. El primero ve el resultado y dice que el primer elemento de la lista es un 8. De este modo, el computador solo hace un recorrido a través de la lista y solo cuando lo necesitamos. Cuando queremos calcular algo a partir de unos datos iniciales en un lenguaje perezoso, solo tenemos que tomar estos datos e ir transformándolos y moldeándolos hasta que se parezcan al resultado que deseamos.
## Tipado estático
Haskell es un lenguaje **tipificado estáticamente**. Cuando compilamos un programa, el compilador sabe que trozos del código son enteros, cuales son cadenas de texto, etc. Gracias a esto un montón de posibles errores son capturados en tiempo de compilación. Si intentamos sumar un número y una cadena de texto, el compilador nos regañará. Haskell usa un fantástico sistema de tipos que posee inferencia de tipos. Esto significa que no tenemos que etiquetar cada trozo de código explícitamente con un tipo porque el sistema de tipos lo puede deducir de forma inteligente. La inferencia de tipos también permite que nuestro código sea más general, si hemos creado una función que toma dos números y los suma y no establecemos explícitamente sus tipos, la función aceptará cualquier par de parámetros que actúen como números.