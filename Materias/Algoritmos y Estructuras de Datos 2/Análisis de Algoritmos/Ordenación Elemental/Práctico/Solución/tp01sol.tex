%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Configuración de Paquetes
\documentclass{article}
\usepackage[framemethod=TikZ]{mdframed}
\usepackage{booktabs}
\usepackage{float}
\usepackage{scrextend}
\usepackage{titletoc}
\usepackage[margin=1in]{geometry} 
\usepackage{amsmath,amsthm,amssymb,amsfonts, fancyhdr, color, comment, graphicx, environ}
\usepackage{xcolor}
\usepackage{mdframed}
\usepackage[shortlabels]{enumitem}
\usepackage{indentfirst}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{tikz}
\usepackage[framemethod=TikZ]{mdframed}
\usepackage{mathptmx}
\usepackage{cfr-lm}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=blue,
}
\setlength{\headheight}{1.5cm}
\renewcommand{\qed}{\quad\qedsymbol}
\usetikzlibrary{calc}
\renewcommand{\familydefault}{\sfdefault}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\fancypagestyle{mipagina}{
    \fancyhf{} % Limpiar encabezado y pie de página
    \fancyhead[L]{Pedro Villar} % Nombre a la izquierda
    \fancyhead[C]{\rightmark} % Texto al centro 
    \fancyhead[R]{Alg. y E.D 2} % Texto a la derecha
    \fancyfoot[C]{\thepage} % Número de página al centro
    \renewcommand{\headrulewidth}{0.4pt} % Grosor de la línea horizontal en el encabezado
}

\pagestyle{mipagina}
\mdfsetup{skipabove=\topskip,skipbelow=\topskip}

% Box de Definición
\newcounter{def}[section]

\NewDocumentEnvironment{defi}{o}{%
    \stepcounter{def}%
    \begin{mdframed}[
        frametitle={%
            \begin{tikzpicture}[baseline=(current bounding box.east),outer sep=0pt]
                \node[anchor=east,rectangle,fill=blue!20,inner xsep=5pt] at (0,0) {\strut\IfValueTF{#1}{Definición~\thedef:~#1}{Definición~\thedef}};
            \end{tikzpicture}%
        },
        innertopmargin=5pt,
        linecolor=blue!20,
        linewidth=2pt,
        topline=true,
        frametitleaboveskip=-\ht\strutbox, % Ajuste de espacio entre título y contenido
        frametitlealignment={\hspace{5pt}}, % Ajuste de espacio entre el borde del frame y el título
    ]
}{%
    \end{mdframed}%
}

% Box de ejemplos
\newcounter{ejemplo}[section]

\NewDocumentEnvironment{ejemplo}{o}{%
    \stepcounter{ejemplo}%
    \begin{mdframed}[
        frametitle={%
            \begin{tikzpicture}[baseline=(current bounding box.east),outer sep=0pt]
                \node[anchor=east,rectangle,fill=brown!30,inner xsep=5pt] at (0,0) {\strut\IfValueTF{#1}{Ejemplo~\theejemplo:~#1}{Ejemplo~\theejemplo}};
            \end{tikzpicture}%
        },
        innertopmargin=5pt,
        linecolor=brown!30,
        linewidth=2pt,
        topline=true,
        frametitleaboveskip=-\ht\strutbox, % Ajuste de espacio entre título y contenido
        frametitlealignment={\hspace{5pt}}, % Ajuste de espacio entre el borde del frame y el título
    ]
}{%
    \end{mdframed}%
}

% Entorno para Métodos (color verde)
\newcounter{metodo}[section]
\NewDocumentEnvironment{metodo}{o}{%
    \stepcounter{metodo}%
    \begin{mdframed}[
        frametitle={%
            \begin{tikzpicture}[baseline=(current bounding box.east),outer sep=0pt]
                \node[anchor=east,rectangle,fill=green!30,inner xsep=5pt] at (0,0) {\strut\IfValueTF{#1}{Método~\themetodo:~#1}{Método~\themetodo}};
            \end{tikzpicture}%
        },
        innertopmargin=5pt,
        linecolor=green!30,
        linewidth=2pt,
        topline=true,
        frametitleaboveskip=-\ht\strutbox, % Ajuste de espacio entre título y contenido
        frametitlealignment={\hspace{5pt}}, % Ajuste de espacio entre el borde del frame y el título
    ]
}{%
    \end{mdframed}%
}

% Entorno para Observaciones (color amarillo más oscuro)
\newcounter{observacion}[section]
\NewDocumentEnvironment{observacion}{o}{%
    \stepcounter{observacion}%
    \begin{mdframed}[
        frametitle={%
            \begin{tikzpicture}[baseline=(current bounding box.east),outer sep=0pt]
                \node[anchor=east,rectangle,fill=yellow!50,inner xsep=5pt] at (0,0) {\strut\IfValueTF{#1}{Observación~\theobservacion:~#1}{Observación~\theobservacion}};
            \end{tikzpicture}%
        },
        innertopmargin=5pt,
        linecolor=yellow!50,
        linewidth=2pt,
        topline=true,
        frametitleaboveskip=-\ht\strutbox, % Ajuste de espacio entre título y contenido
        frametitlealignment={\hspace{5pt}}, % Ajuste de espacio entre el borde del frame y el título
    ]
}{%
    \end{mdframed}%
}

% Entorno para Ejercicio
\newcounter{ejer}[section]
\NewDocumentEnvironment{ejer}{o}{%
    \stepcounter{ejer}%
    \begin{mdframed}[
        frametitle={%
            \begin{tikzpicture}[baseline=(current bounding box.east),outer sep=0pt]
                \node[anchor=east,rectangle,fill=black!30,inner xsep=5pt] at (0,0) {\strut\IfValueTF{#1}{Ejercicio~\theejer:~#1}{Ejercicio~\theejer}};
            \end{tikzpicture}%
        },
        innertopmargin=5pt,
        linecolor=black!30,
        linewidth=2pt,
        topline=true,
        frametitleaboveskip=-\ht\strutbox, % Ajuste de espacio entre título y contenido
        frametitlealignment={\hspace{5pt}}, % Ajuste de espacio entre el borde del frame y el título
    ]
}{%
    \end{mdframed}%
}

\newenvironment{solution}
    {\textit{Solución:}}
    {}


\newcounter{pascalcode}[section]

\renewcommand{\thepascalcode}{\arabic{section}.\arabic{pascalcode}}

\lstdefinelanguage{pascal-like}{
  morekeywords={var, type, tuple, enumerate, fi, ret, downto, where, proc, fun, in, out, if, then, else, while, do, for, to, end, od},
  morecomment=[s]{\{-}{-\}},
  morestring=[b]",
  sensitive=true,
  keywordstyle=\color{purple},
  commentstyle=\color{green!70!black},
  stringstyle=\color{blue!70!black},
  numbers=left,
  numberstyle=\tiny\color{gray},
  alsoletter={:,=,+,-,*,>,<,(,)},
  morekeywords=[2]{:,=,+,-,*,>,<,(,),&,&&,||,!,!=,==},
  keywordstyle=[2]{\color{blue}},
  literate={:=}{{\textcolor{blue}{:=}}}2,
  morekeywords=[3]{nat, array, of, int, real, bool, char}, 
  keywordstyle=[3]{\color{green!40!black}},
  literate={\^}{{\textasciicircum}}1,
}

\lstnewenvironment{pascallike}[1][]{
  \refstepcounter{pascalcode}
  \lstset{
    language=pascal-like,
    numbers=left,
    numberstyle=\tiny\color{gray},
    captionpos=b,
    #1
  }
}{\phantomsection\addcontentsline{lol}{section}{Código \thepascalcode}}


%Configuraciones adicionales
\binoppenalty=\maxdimen 
\relpenalty=\maxdimen 
\setlength{\parindent}{0pt}

\begin{document}

\section*{Ejercicio 1}
Escribí algoritmos para resolver cada uno de los siguientes problemas sobre un arreglo a de posiciones $1$ a $n$, utilizando do. Elegí en cada caso entre estos dos encabezados el que sea más adecuado:

\begin{pascallike}
proc nombre (in/out a: array [1..n] of nat)
    ...
end proc
\end{pascallike}
\begin{pascallike}
proc nombre (out a: array [1..n] of nat)
    ...
end proc
\end{pascallike}
\begin{itemize}
    \item[(a)] Inicializar cada componente del arreglo con el valor $0$.
    \item[(b)] Inicializar el arreglo con los primeros $n$ números naturales positivos.
    \item[(c)] Inicializar el arreglo con los primeros $n$ números naturales impares.
    \item[(d)] Incrementar las posiciones impares del arreglo y dejar intactas las posiciones pares.  
\end{itemize}
\textbf{Punto a:} Inicializar cada componente del arreglo con el valor $0$.
\begin{pascallike}
proc inicializarConCero (out a: array [1..n] of nat)
  i := 1
  do i <= n -> 
    a[i] := 0
    i := i + 1
  od
end proc
\end{pascallike}

\textbf{Punto b:} Inicializar el arreglo con los primeros $n$ números naturales positivos.
\begin{pascallike}
proc inicializarConNaturales (out a: array [1..n] of nat)
  i := 1
  do i <= n -> 
    a[i] := i
    i := i + 1
  od
end proc
\end{pascallike}

\textbf{Punto c:} Inicializar el arreglo con los primeros $n$ números naturales impares.
\begin{pascallike}
proc inicializarConImpares (out a: array [1..n] of nat)
  i := 1
  do i <= n -> 
    a[i] := 2 * i - 1
    i := i + 1
  od
end proc
\end{pascallike}

\newpage
\textbf{Punto d:} Incrementar las posiciones impares del arreglo y dejar intactas las posiciones pares.
\begin{pascallike}
proc incrementarImpares (in/out a: array [1..n] of nat)
  i := 1
  do i <= n -> 
    if i mod 2 = 1 then
      a[i] := a[i] + 1
    fi
    i := i + 1
  od
end proc
\end{pascallike}

\section*{Ejercicio 2}
Transformá cada uno de los algoritmos anteriores en uno equivalente que utilice \textbf{for...to} 
\subsection*{Solución}
\textbf{Punto a:} Inicializar cada componente del arreglo con el valor $0$.
\begin{pascallike}
proc inicializarConCero (out a: array [1..n] of nat)
  for i := 1 to n do
    a[i] := 0
  od
end proc
\end{pascallike}

\textbf{Punto b:} Inicializar el arreglo con los primeros $n$ números naturales positivos.
\begin{pascallike}
proc inicializarConNaturales (out a: array [1..n] of nat)
  for i := 1 to n do
    a[i] := i
  od
end proc
\end{pascallike}

\textbf{Punto c:} Inicializar el arreglo con los primeros $n$ números naturales impares.
\begin{pascallike}
proc inicializarConImpares (out a: array [1..n] of nat)
  for i := 1 to n do
    a[i] := 2 * i - 1
  od
end proc
\end{pascallike}

\textbf{Punto d:} Incrementar las posiciones impares del arreglo y dejar intactas las posiciones pares.
\begin{pascallike}
proc incrementarImpares (in/out a: array [1..n] of nat)
  for i := 1 to n do
    if i mod 2 = 1 then
      a[i] := a[i] + 1
    fi
  od
end proc
\end{pascallike}

\newpage

\section*{Ejercicio 3}
Escribí un algoritmo que reciba un arreglo a de posiciones 1 a n y determine si el arreglo recibido
está ordenado o no. Explicá en palabras \textbf{qué} hace el algoritmo. Explicá en palabras \textbf{cómo} lo hace.

\subsection*{Solución}
\begin{pascallike}
fun estaOrdenado (a: array [1..n] of nat) ret r: bool
  for i := 1 to n - 1 do
    if a[i] > a[i + 1] then
      r := false
    else
      skip
    fi
  od
end fun
\end{pascallike}

\textbf{¿Qué hace el algoritmo?} El algoritmo recibe un arreglo de números naturales y retorna un valor booleano que indica si el arreglo está ordenado o no.

\textbf{¿Cómo lo hace?} El algoritmo recorre el arreglo desde la primera posición hasta la penúltima, comparando cada elemento con el siguiente. Si encuentra un elemento mayor que el siguiente, retorna \textbf{false}, indicando que el arreglo no está ordenado. Si recorre todo el arreglo sin encontrar un elemento mayor que el siguiente, retorna \textbf{true}, indicando que el arreglo está ordenado.

\section*{Ejercicio 4}
Ordená los siguientes arreglos, utilizando el algoritmo de ordenación por selección visto en clase. Mostrá en cada paso de iteración cuál es el elemento seleccionado y cómo queda el arreglo después de cada intercambio.

\begin{itemize}
    \item[(a)] $[7, 1, 10, 3, 4, 9, 5]$
    \item[(b)] $[5, 4, 3, 2, 1]$
    \item[(c)] $[1, 2, 3, 4, 5]$
\end{itemize}

\subsection*{Solución}
\textbf{Punto a:} 
$$[7, 1, 10, 3, 4, 9, 5]$$
= \{ Se encuentra que el número más pequeño es el $1$, por lo que se intercambia con el $7$ \}
$$[1, 7, 10, 3, 4, 9, 5]$$
= \{ Se encuentra que el número más pequeño es el $3$, por lo que se intercambia con el $7$ \}
$$[1, 3, 10, 7, 4, 9, 5]$$
= \{ Se encuentra que el número más pequeño es el $4$, por lo que se intercambia con el $10$ \}
$$[1, 3, 4, 7, 10, 9, 5]$$
= \{ Se encuentra que el número más pequeño es el $5$, por lo que se intercambia con el $10$ \}
$$[1, 3, 4, 5, 10, 9, 7]$$
= \{ Se encuentra que el número más pequeño es el $7$, por lo que se intercambia con el $10$ \}
$$[1, 3, 4, 5, 7, 9, 10]$$


\textbf{Punto b:}
$$[5, 4, 3, 2, 1]$$
= \{ Se encuentra que el número más pequeño es el $1$, por lo que se intercambia con el $5$ \}
$$[1, 4, 3, 2, 5]$$
= \{ Se encuentra que el número más pequeño es el $2$, por lo que se intercambia con el $4$ \}
$$[1, 2, 3, 4, 5]$$

\textbf{Punto c:}
$$[1, 2, 3, 4, 5]$$
= \{ El arreglo ya está ordenado, por lo que no se realizan intercambios \}

\section*{Ejercicio 5}
Calculá de la manera más exacta y simple posible el número de asignaciones a la variable t de los siguientes algoritmos. Las ecuaciones que se encuentran al final del práctico pueden ayudarte.

\begin{itemize}
  \item[(a)]
  \begin{pascallike}
    t := 0
    for i := 1 to n do
      for j := 1 to n^2 do
        for k := 1 to n^3 do
          t := t + 1
        od
      od
    od
  \end{pascallike}
  \item[(b)]
  \begin{pascallike}
    t := 0
    for i := 1 to n do
      for j := 1 to i do
        for k := j to j+3 do
          t := t + 1
        od
      od
    od
  \end{pascallike}
\end{itemize}

\newpage
\subsection*{Solución}
\textbf{Punto a:}
\begin{pascallike}
  ops(t := 0
  for i := 1 to n do
    for j := 1 to n^2 do
      for k := 1 to n^3 do
        t := t + 1
      od
    od
  od)
\end{pascallike}
Escro el bucle en forma de sumatorias 
\begin{equation*}
  \sum_{i=1}^{n} \left(  \sum_{j=1}^{n^2} \left) \sum_{k=1}^{n^3} t := t+1 \right) \right)
\end{equation*}

Ahora aplico la función ops a la secuencia:

\begin{equation*}
  ops(t := 0) + \sum_{i=1}^{n} \left(  ops\left(\sum_{j=1}^{n^2} \sum_{k=1}^{n^3} t := t+1 \right) \right)
\end{equation*}

= \{ $ops=\sum_{j=1}^{n^2}$ es una sumatoria de $n^2$ elementos, por lo que vale $n^2$ \}

\begin{equation*}
  ops(t := 0) + \sum_{i=1}^{n} \left(  n^2 \cdot ops \left(\sum_{k=1}^{n^3} t := t+1 \right) \right)
\end{equation*}

= \{ $ops(t := 0)$ es una asignación, por lo que vale $1$ \}

\begin{equation*}
  1 + \sum_{i=1}^{n} \left(  n^2 \cdot ops \left(\sum_{k=1}^{n^3} t := t+1 \right) \right)
\end{equation*}

= \{ $ops \left(\sum_{k=1}^{n^3} t := t+1 \right)$ es una sumatoria de $n^3$ elementos, por lo que vale $n^3$ \}

\begin{equation*}
  1 + \sum_{i=1}^{n} \left(  n^2 \cdot n^3 \right)
\end{equation*}

= \{ Resuelvo la sumatoria interna \}

\begin{equation*}
  1 + \sum_{i=1}^{n} \left(  n^5 \right)
\end{equation*}

= \{ Resuelvo la sumatoria externa \}

\begin{equation*}
  1 + n \cdot n^5
\end{equation*}

= \{ Resuelvo la multiplicación \}

\begin{equation*}
  1 + n^6
\end{equation*}

\newpage

\textbf{Punto b:}
\begin{pascallike}
  ops(t := 0
  for i := 1 to n do
    for j := 1 to i do
      for k := j to j+3 do
        t := t + 1
      od
    od
  od)
\end{pascallike}
Escro el bucle en forma de sumatorias
\begin{equation*}
  \sum_{i=1}^{n} \left(  \sum_{j=1}^{i} \left) \sum_{k=j}^{j+3} t := t+1 \right) \right)
\end{equation*}

Ahora aplico la función ops a la secuencia:

\begin{equation*}
  ops(t := 0) + \sum_{i=1}^{n} \left(  ops\left(\sum_{j=1}^{i} \sum_{k=j}^{j+3} t := t+1 \right) \right)
\end{equation*}

= \{ $ops=\sum_{j=1}^{i}$ es una sumatoria de $i$ elementos, por lo que vale $i$ \}

\begin{equation*}
  ops(t := 0) + \sum_{i=1}^{n} \left(  i \cdot ops \left(\sum_{k=j}^{j+3} t := t+1 \right) \right)
\end{equation*}

= \{ $ops(t := 0)$ es una asignación, por lo que vale $1$ \}

\begin{equation*}
  1 + \sum_{i=1}^{n} \left(  i \cdot ops \left(\sum_{k=j}^{j+3} t := t+1 \right) \right)
\end{equation*}

= \{ $ops \left(\sum_{k=j}^{j+3} t := t+1 \right)$ es una sumatoria de $4$ elementos, por lo que vale $4$ \}

\begin{equation*}
  1 + \sum_{i=1}^{n} \left(  4 \cdot i \right)
\end{equation*}

= \{ Resuelvo la sumatoria \}

\begin{equation*}
  1 + 4 \cdot \sum_{i=1}^{n} \left(  i \right)
\end{equation*}

= \{ Resuelvo la sumatoria \}

\begin{equation*}
  1 + 4 \cdot \frac{n \cdot (n+1)}{2}
\end{equation*}

= \{ Resuelvo la multiplicación \}

\begin{equation*}
  1 + 2 \cdot n \cdot (n+1)
\end{equation*}

= \{ Resuelvo la multiplicación \}

\begin{equation*}
  1 + 2 \cdot n^2 + 2 \cdot n
\end{equation*}

\newpage

\section*{Ejercicio 6}
Descifrá qué hacen los siguientes algoritmos, explicar cómo lo hacen y reescribirlos asignando nombres adecuados a todos los identificadores
\begin{pascallike}
proc p (in/out a: array [1..n] of T)
  var x: nat
  for i := n downto 2 do
    x := f(a,i)
    swap(a,i,x)
  od
end proc
\end{pascallike}

\begin{pascallike}
fun f (a: array [1..n] of T, i: nat) ret x: nat
  x := 1
  for j := 2 to i do
    if a[j] > a[x] then
      x := j
    fi
  od
end fun
\end{pascallike}

\subsection*{Solución}
\textbf{Algoritmo p:} El algoritmo recibe un arreglo de elementos de tipo T y lo ordena de manera descendente. Para ello, recorre el arreglo desde la última posición hasta la segunda, en cada iteración busca el elemento más grande en el subarreglo que va desde la primera posición hasta la posición actual y lo intercambia con el elemento en la posición actual.
Se podria escribir de la siguiente manera:
\begin{pascallike}
proc ordenarDescendente (in/out a: array [1..n] of T)
  var posMax: nat
  for i := n downto 2 do
    posMax := buscarMaximo(a,i)
    swap(a,i,posMax)
  od
end proc
\end{pascallike}

\textbf{Función f:} La función recibe un arreglo de elementos de tipo T y un número natural $i$, y retorna la posición del elemento más grande en el subarreglo que va desde la primera posición hasta la posición $i$. Para ello, recorre el subarreglo desde la segunda posición hasta la posición $i$, en cada iteración compara el elemento actual con el elemento más grande encontrado hasta el momento y si el elemento actual es mayor, actualiza la posición del elemento más grande.
Se podria escribir de la siguiente manera:
\begin{pascallike}
fun buscarMaximo (a: array [1..n] of T, i: nat) ret posMax: nat
  posMax := 1
  for j := 2 to i do
    if a[j] > a[posMax] then
      posMax := j
    fi
  od
end fun
\end{pascallike}

\newpage

\section*{Ejercicio 7}
Ordená los arreglos del ejercicio 4 utilizando el algoritmo de ordenación por inserción. Mostrá en cada paso de iteración las comparaciones e intercambios realizados hasta ubicar el elemento en su posición.

\subsection*{Solución}
\textbf{Punto a:}
$$[7, 1, 10, 3, 4, 9, 5]$$
= \{ Selecciono el $1$ y lo comparo con el $7$, como el $1$ es menor que el $7$, lo intercambio con el $7$ \}
$$[1, 7, 10, 3, 4, 9, 5]$$
= \{ Selecciono el $10$ y lo comparo con el $7$, como el $10$ es mayor que el $7$, no hago nada \}
$$[1, 7, 10, 3, 4, 9, 5]$$
= \{ Selecciono el $3$ y lo comparo con el $10$, como el $3$ es menor que el $10$, lo comparo con el $7$, como el $3$ es menor que el $7$, lo comparo con el $1$, como el $3$ es mayor que el $1$, lo intercambio con el $3$ al $7$\}
$$[1, 3, 7, 10, 4, 9, 5]$$
= \{ Selecciono el $4$ y lo comparo con el $10$, como el $4$ es menor que el $10$, lo comparo con el $7$, como el $4$ es menor que el $7$, lo comparo con el $3$, como el $4$ es mayor que el $3$, lo intercambio con el $4$ al $7$\}
$$[1, 3, 4, 7, 10, 9, 5]$$
= \{ Selecciono el $9$ y lo comparo con el $10$, como el $9$ es menor que el $10$, lo comparo con el $7$, como el $9$ es menor que el $7$, lo comparo con el $4$, como el $9$ es mayor que el $4$, lo comparo con el $3$, como el $9$ es mayor que el $3$, lo comparo con el $1$, como el $9$ es mayor que el $1$, lo intercambio con el $9$ al $10$\}
$$[1, 3, 4, 7, 9, 10, 5]$$
= \{ Selecciono el $5$ y lo comparo con el $10$, como el $5$ es menor que el $10$, lo comparo con el $9$, como el $5$ es menor que el $9$, lo comparo con el $7$, como el $5$ es menor que el $7$, lo comparo con el $4$, como el $5$ es mayor que el $4$, lo comparo con el $3$, como el $5$ es mayor que el $3$, lo comparo con el $1$, como el $5$ es mayor que el $1$, lo intercambio con el $5$ al $7$\}
$$[1, 3, 4, 5, 7, 9, 10]$$

\textbf{Punto b:}
$$[5, 4, 3, 2, 1]$$
= \{ Selecciono el $4$ y lo comparo con el $5$, como el $4$ es menor que el $5$, lo comparo con el $3$, como el $4$ es mayor que el $3$, lo comparo con el $2$, como el $4$ es mayor que el $2$, lo comparo con el $1$, como el $4$ es mayor que el $1$, lo intercambio con el $4$ al $5$\}
$$[4, 5, 3, 2, 1]$$
= \{ Selecciono el $3$ y lo comparo con el $5$, como el $3$ es menor que el $5$, lo comparo con el $4$, como el $3$ es menor que el $4$, lo comparo con el $2$, como el $3$ es mayor que el $2$, lo comparo con el $1$, como el $3$ es mayor que el $1$, lo intercambio con el $3$ al $4$\}
$$[3, 4, 5, 2, 1]$$
= \{ Selecciono el $2$ y lo comparo con el $5$, como el $2$ es menor que el $5$, lo comparo con el $4$, como el $2$ es menor que el $4$, lo comparo con el $3$, como el $2$ es menor que el $3$, lo comparo con el $1$, como el $2$ es mayor que el $1$, lo intercambio con el $2$ al $3$\}
$$[2, 3, 4, 5, 1]$$
= \{ Selecciono el $1$ y lo comparo con el $5$, como el $1$ es menor que el $5$, lo comparo con el $4$, como el $1$ es menor que el $4$, lo comparo con el $3$, como el $1$ es menor que el $3$, lo comparo con el $2$, como el $1$ es menor que el $2$, lo intercambio con el $1$ al $2$\}
$$[1, 2, 3, 4, 5]$$

\textbf{Punto c:}
$$[1, 2, 3, 4, 5]$$
= \{ El arreglo ya está ordenado, por lo que no se realizan intercambios \}

\section*{Ejercicio 8}
Calculá el orden del número de asignaciones a la variable t de los siguientes algoritmos.
\newline \textbf{(a)}
\begin{pascallike}
t := 1
do t < n 
  t := t * 2
od
\end{pascallike}

\textbf{(b)}
\begin{pascallike}
t := n
do t > 0 do
  t := t div 2
od
\end{pascallike}

\textbf{(c)}
\begin{pascallike}
for i := 1 to n do
  t := i
  do t > 0 do
    t := t div 2
  od
od
\end{pascallike} 

\textbf{(d)}
\begin{pascallike}
for i := 1 to n do
  t := i
  do t > 0 do
    t := t - 2
  od
od
\end{pascallike}

\subsection*{Solución}
\textbf{Punto a:}
\begin{pascallike}
t := 1
do t < n 
  t := t * 2
od
\end{pascallike}
El algoritmo realiza una asignación y luego realiza una multiplicación en cada iteración. El número de iteraciones es el menor número $k$ tal que $2^k \geq n$. Por lo tanto, el orden del número de asignaciones es $O(\log_2 n)$.

\newpage
\textbf{Punto b:}
\begin{pascallike}
t := n
do t > 0 do
  t := t div 2
od
\end{pascallike}
El algoritmo realiza una asignación y luego realiza una división en cada iteración. El número de iteraciones es el menor número $k$ tal que $n \div 2^k = 0$. Por lo tanto, el orden del número de asignaciones es $O(\log_2 n)$.

\textbf{Punto c:}
\begin{pascallike}
for i := 1 to n do
  t := i
  do t > 0 do
    t := t div 2
  od
od
\end{pascallike}
El algoritmo realiza una asignación y luego realiza una división en cada iteración. El número de iteraciones es el número $n$. Por lo tanto, el orden del número de asignaciones es $O(n \cdot \log_2 n)$.

\textbf{Punto d:}
\begin{pascallike}
for i := 1 to n do
  t := i
  do t > 0 do
    t := t - 2
  od
od
\end{pascallike}
El algoritmo realiza una asignación y luego realiza una resta en cada iteración. El número de iteraciones es el número $n$. Por lo tanto, el orden del número de asignaciones es $O(n)$.

\section*{Ejercicio 9}
Calculá el orden del número de comparaciones del algoritmo del ejercicio 3.

\subsection*{Solución}
\begin{pascallike}
fun estaOrdenado (a: array [1..n] of nat) ret r: bool
  for i := 1 to n - 1 do
    if a[i] > a[i + 1] then
      r := false
    else
      skip
    fi
  od
end fun
\end{pascallike}
El algoritmo realiza una comparación en cada iteración del bucle. El número de iteraciones es el menor número $k$ tal que $i + k \geq n-1$. Por lo tanto, el orden del número de comparaciones es $O(n)$.

$$ ops\left( \sum_{i=1}^{n-1} (if...else)) \right)$$
$$ ops\left( \sum_{i=1}^{n-1} 1 \right) = n$$

\section*{Ejercicio 10}
Descifrá qué hacen los siguientes algoritmos, explicar cómo lo hacen y reescribirlos asignando nombres adecuados a todos los identificadores.
\begin{pascallike}
proc q (in/out a: array [1..n] of T)
  for i := n-1 downto 1 do
    r(a,i)
  od
end proc
\end{pascallike}

\begin{pascallike}
proc r (in/out a: array [1..n] of T, in i: nat)
  var j: nat
  j := i
  do j < n && a[j] > a[j+1] ->
    swap(a,j+1,j)
    j := j + 1
  od
end proc
\end{pascallike}

\subsection*{Solución}
\textbf{Algoritmo q:} El algoritmo recibe un arreglo de elementos de tipo T y lo ordena de manera ascendente. Para ello, recorre el arreglo desde la penúltima posición hasta la primera, en cada iteración llama a la función r con el arreglo y la posición actual.
Se podria escribir de la siguiente manera:
\begin{pascallike}
proc ordenarAscendente (in/out a: array [1..n] of T)
  for i := n-1 downto 1 do
    ordenar(a,i)
  od
end proc
\end{pascallike}

\textbf{Algoritmo r:} El algoritmo recibe un arreglo de elementos de tipo T y un número natural $i$, y realiza un intercambio entre el elemento en la posición $j$ y el elemento en la posición $j+1$ hasta que el elemento en la posición $j$ sea menor o igual que el elemento en la posición $j+1$ o hasta que la posición $j$ sea la última posición del arreglo.
Se podria escribir de la siguiente manera:
\begin{pascallike}
proc ordenar (in/out a: array [1..n] of T, in i: nat)
  var j: nat
  j := i
  do j < n && a[j] > a[j+1] ->
    swap(a,j+1,j)
    j := j + 1
  od
end proc
\end{pascallike}


\end{document}